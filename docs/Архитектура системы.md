# Практическая работа
## «Проектирование архитектуры системы складского учёта»

**Студент:** Чуляков Семён Игоревич  
**Группа:** 11/2-РПО-24/2  
**Дата:** 13.12.2025

**Соответствие стандартам:** Архитектура разработана в соответствии с процессами жизненного цикла ПО (ГОСТ Р ИСО/МЭК 12207).

---

### 1. АНАЛИЗ ТРЕБОВАНИЙ И ОБОСНОВАНИЕ ВЫБОРА АРХИТЕКТУРЫ

#### 1.1. Функциональные требования
1. **Управление номенклатурой и местами хранения:**
   - Ведение справочника товаров с характеристиками (артикул, категория, производитель, вес, габариты).
   - Привязка товаров к конкретным местам хранения (стеллаж/полка/ячейка).
   - Управление минимальными и максимальными остатками.

2. **Складской документооборот:**
   - Оформление приходных накладных (поступление от поставщиков).
   - Оформление расходных накладных (отпуск в подразделения, списание).
   - Регистрация внутренних перемещений.
   - Проведение инвентаризаций.

3. **Контроль и отчётность:**
   - Отслеживание остатков в режиме реального времени.
   - Формирование отчётов по движениям, остаткам, срокам годности.
   - Контроль доступа по ролям (кладовщик, менеджер, администратор, аудитор).

#### 1.2. Нефункциональные требования
- **Производительность:** Обработка до 1000 операций в час (приёмка, списание, перемещение).
- **Доступность:** 99,9% (плановые работы не более 8 часов в месяц).
- **Время отклика:** < 2 секунд для основных операций.
- **Безопасность:** Разграничение прав доступа, шифрование паролей, журнал аудита.
- **Масштабируемость:** Возможность увеличения количества рабочих мест до 100.

#### 1.3. Обоснование выбора многоуровневой (N-Layer) архитектуры
Для учебного проекта выбрана **многоуровневая архитектура** вместо микросервисной по следующим причинам:

| Критерий | Многоуровневая архитектура | Микросервисная архитектура | Обоснование выбора |
|----------|----------------------------|----------------------------|-------------------|
| **Сложность разработки** | Низкая/средняя | Высокая | Учебный проект, ограниченные сроки |
| **Целостность транзакций** | Высокая (ACID) | Сложная (Saga pattern) | Критично для операций приёмки/списания |
| **Развёртывание** | Простое (один пакет) | Сложное (оркестрация) | Отсутствие DevOps-инфраструктуры |
| **Производительность** | Высокая (внутрипроцессное взаимодействие) | Ниже (сетевое взаимодействие) | Необходима высокая скорость операций |
| **Поддержка** | Простая | Сложная | Проект будет поддерживаться одним разработчиком |

**Вывод:** Для системы складского учёта с требованиями к целостности данных и простотой разработки **многоуровневая архитектура является оптимальным выбором**.

---

### 2. ДЕТАЛЬНОЕ ОПИСАНИЕ КОМПОНЕНТОВ СИСТЕМЫ

#### 2.1. Уровень представления (Presentation Layer)
**Назначение:** Взаимодействие с пользователем, отображение данных, приём команд.

**Технологии:** React.js (SPA) или WPF (Desktop приложение на C#).
**Компоненты:**
1. **Модуль аутентификации:** Форма входа, восстановление пароля.
2. **Модуль номенклатуры:** Интерфейс для работы со справочником товаров.
3. **Модуль документов:** Создание/просмотр приходных, расходных накладных.
4. **Модуль склада:** Просмотр остатков, поиск по ячейкам, перемещения.
5. **Модуль отчётов:** Формирование и экспорт отчётов.

#### 2.2. Уровень бизнес-логики (Business Logic Layer)
**Назначение:** Реализация бизнес-правил, валидация, обработка операций.

**Технологии:** ASP.NET Core Web API (C#).
**Сервисы:**
1. **Сервис аутентификации и авторизации (AuthService):**
   - Аутентификация пользователей (JWT токены).
   - Управление ролями и правами доступа.
   - Ведение журнала аудита.

2. **Сервис номенклатуры (ProductService):**
   - Управление справочником товаров, категорий, производителей.
   - Валидация данных (уникальность артикула и т.д.).

3. **Сервис складских операций (WarehouseService):**
   - Обработка приёмки товара (создание `ReceiptDocuments`, обновление `Warehouse`).
   - Обработка списания (проверка остатков, создание `IssueDocuments`).
   - Управление внутренними перемещениями (`InternalMovements`).
   - Проведение инвентаризаций (`InventoryChecks`, `InventoryResults`).

4. **Сервис отчётности (ReportService):**
   - Формирование отчётов по остаткам, движениям, срокам годности.
   - Экспорт в PDF, Excel.

#### 2.3. Уровень доступа к данным (Data Access Layer)
**Назначение:** Абстракция для работы с базой данных.

**Технологии:** Entity Framework Core (ORM), Dapper (для сложных запросов).
**Компоненты:**
1. **Реализация репозиториев (Repository Pattern):**
   - `IProductRepository`, `IWarehouseRepository`, `IDocumentRepository`.
   - Изоляция кода доступа к данным от бизнес-логики.

2. **Unit of Work:** Обеспечение целостности транзакций (например, приёмка товара должна обновить и документ, и остатки атомарно).

#### 2.4. Уровень данных (Data Layer)
**Назначение:** Хранение и управление данными.

**Технологии:** Microsoft SQL Server 2019/2022.
**База данных:** `WarehouseManagement` (уже создана и содержит 12 таблиц).
**Основные таблицы:** `Users`, `Products`, `Warehouse`, `ReceiptDocuments`, `ReceiptItems`, `IssueDocuments`, `IssueItems`, `InternalMovements`, `InventoryChecks`, `InventoryResults`.

---

### 3. ДЕТАЛЬНЫЕ СХЕМЫ ВЗАИМОДЕЙСТВИЯ

#### 3.1. Полная архитектурная схема

```mermaid
graph TB
    subgraph "Уровень представления (Presentation Layer)"
        UI[Веб-интерфейс / React]
        Mobile[Мобильное приложение]
    end
    
    subgraph "Уровень бизнес-логики (Business Logic Layer)"
        API[ASP.NET Core Web API]
        Auth[Сервис аутентификации]
        ProductS[Сервис номенклатуры]
        WarehouseS[Сервис складских операций]
        ReportS[Сервис отчётности]
    end
    
    subgraph "Уровень доступа к данным (Data Access Layer)"
        DAL[Репозитории / Entity Framework]
    end
    
    subgraph "Уровень данных (Data Layer)"
        DB[(База данных<br/>SQL Server)]
    end
    
    UI --> API
    Mobile --> API
    
    API --> Auth
    API --> ProductS
    API --> WarehouseS
    API --> ReportS
    
    Auth --> DAL
    ProductS --> DAL
    WarehouseS --> DAL
    ReportS --> DAL
    
    DAL --> DB
```

**Пояснение к схеме:** Архитектура системы разделена на четыре чётких уровня, что обеспечивает слабую связанность компонентов и простоту поддержки. Все запросы от клиентов проходят через единый API, который делегирует выполнение соответствующим сервисам.

#### 3.2. Схема базы данных (ER-диаграмма)

*Ссылка на актуальную ER-диаграмму: [ER_Diagram.png](../diagrams/ER_Diagram.png)*

**Ключевые связи:**
- `Users` → `ReceiptDocuments`, `IssueDocuments` (пользователь создаёт документы)
- `Products` → `Warehouse` (товар хранится в конкретных ячейках)
- `ReceiptDocuments` → `ReceiptItems` (состав приходной накладной)
- `IssueDocuments` → `IssueItems` (состав расходной накладной)
- `Products` → `InventoryResults` (результаты инвентаризации по товарам)

### 4. ПРОЦЕССЫ И ПОСЛЕДОВАТЕЛЬНОСТИ

#### 4.1. Диаграмма процесса оформления приходной накладной

```mermaid
sequenceDiagram
    participant Кладовщик
    participant UI as Веб-интерфейс
    participant API as WarehouseService
    participant DB as База данных
    
    Кладовщик->>UI: Создать приходную накладную
    UI->>API: POST /api/receipts (данные накладной)
    
    API->>DB: Проверить существование товаров
    DB-->>API: Данные товаров
    
    API->>API: Рассчитать суммы, валидировать данные
    
    loop Для каждого товара
        API->>DB: Проверить доступность ячейки
        DB-->>API: Статус ячейки
        API->>DB: Зарезервировать место (при необходимости)
    end
    
    API->>DB: Создать запись ReceiptDocuments
    API->>DB: Создать записи ReceiptItems
    DB-->>API: Подтверждение создания
    
    API-->>UI: Успешный ответ, номер документа
    UI-->>Кладовщик: Накладная создана (статус "Подтверждена")
    
    Note over Кладовщик,DB: ФИЗИЧЕСКАЯ ПРИЁМКА ТОВАРА
    
    Кладовщик->>UI: Подтвердить приёмку
    UI->>API: PATCH /api/receipts/{id}/complete
    API->>DB: Обновить остатки (Warehouse.quantity)
    API->>DB: Обновить статус документа на "Завершена"
    DB-->>API: Подтверждение
    API-->>UI: Успешный ответ
    UI-->>Кладовщик: Приёмка завершена
```

**Пояснение:** Процесс разделён на две фазы: создание документа (электронное) и физическая приёмка с обновлением остатков. Это соответствует реальной практике работы склада.

### 5. ТЕХНИЧЕСКИЕ ХАРАКТЕРИСТВИКИ

#### 5.1. Технологический стек
| Компонент | Технология | Версия | Обоснование выбора |
|-----------|------------|---------|-------------------|
| **Backend** | ASP.NET Core | 6.0/8.0 | Высокая производительность, кроссплатформенность, богатая экосистема |
| **Frontend** | React.js + TypeScript | 18.x | Современный UI, компонентный подход, большое сообщество |
| **База данных** | Microsoft SQL Server | 2019/2022 | Надёжность, транзакционная целостность, знакомство по учебной программе |
| **ORM** | Entity Framework Core | 7.0/8.0 | Удобная работа с БД, миграции, LINQ |
| **Аутентификация** | JWT (JSON Web Tokens) | - | Стандарт де-факто для REST API, stateless |
| **Контейнеризация** | Docker | 24.x | Единая среда разработки/развёртывания |

#### 5.2. API спецификация (пример основных endpoints)
```
/api/v1/
├── auth/
│   ├── POST   /login
│   ├── POST   /register
│   └── GET    /profile
├── products/
│   ├── GET    /              # Список товаров с фильтрацией
│   ├── POST   /              # Создать товар
│   ├── GET    /{id}          # Получить товар по ID
│   └── PUT    /{id}          # Обновить товар
├── warehouse/
│   ├── GET    /stock         # Остатки товаров
│   ├── GET    /cells/{id}    # Информация по ячейке
│   └── POST   /move          # Переместить товар
├── receipts/
│   ├── POST   /              # Создать приходную накладную
│   ├── GET    /{id}          # Получить накладную
│   └── PATCH  /{id}/complete # Завершить приёмку
└── reports/
    ├── GET    /stock         # Отчёт по остаткам
    └── GET    /movements     # Отчёт по движениям
```

#### 5.3. Требования к инфраструктуре (для развёртывания)
- **Сервер приложений:** Windows Server 2022 или Linux (Ubuntu 22.04)
- **Память:** 8 GB RAM минимум
- **Процессор:** 4 ядра
- **Диск:** 100 GB SSD (для БД и приложения)
- **Резервное копирование:** Ежедневное автоматическое

### 6. ОБЕСПЕЧЕНИЕ КАЧЕСТВА И БЕЗОПАСНОСТЬ

#### 6.1. Стратегия тестирования
1. **Модульные тесты (Unit Tests):** xUnit/NUnit для backend, Jest для frontend. Покрытие > 70% критической бизнес-логики.
2. **Интеграционные тесты:** TestContainers для тестирования взаимодействия с БД.
3. **End-to-End тесты:** Cypress для тестирования ключевых пользовательских сценариев.
4. **Нагрузочное тестирование:** k6 или JMeter для проверки производительности.

#### 6.2. Меры безопасности
- **HTTPS/TLS** для всех внешних соединений.
- **Валидация входных данных** на всех уровнях (UI, API, БД).
- **Защита от SQL-инъекций** через параметризованные запросы (EF Core).
- **Rate limiting** (ограничение запросов) на уровне API.
- **Регулярное обновление зависимостей** для устранения уязвимостей.

### 7. ЗАКЛЮЧЕНИЕ И ВЫВОДЫ

Предложенная **многоуровневая архитектура** для системы складского учёта позволяет:

1. **Обеспечить целостность данных** за счёт транзакционности на уровне БД.
2. **Упростить разработку и отладку** по сравнению с микросервисным подходом.
3. **Легко масштабироваться** вертикально (усиление сервера) при росте нагрузки.
4. **Минимизировать сложность развёртывания** — один пакет для backend, один для frontend.
5. **Соответствовать учебным целям** — демонстрирует применение современных, но не избыточно сложных технологий.

**Архитектура является сбалансированным решением**, учитывающим функциональные требования системы, ограничения учебного проекта и лучшие практики индустрии.

---
**Разработчик архитектуры:**  
Чуляков Семён Игоревич  
*Студент группы 11/2-РПО-24/2*
